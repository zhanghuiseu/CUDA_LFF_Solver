	/*
	 * ConstraintParameter.cu
	 * 
	 * ***************   Notice   ***************
	 * Auto Generated By ATPC on:2018-01-14 17:53:17
	 * Author: ZhangHui
	 * 
	 */ 

	#include <iostream>

	#include <vector>

	#include <map>

	#include "./../solver/type.h"
	#include "./../solver/ConstantValue.h"
	#include "./../model/RuntimeValue.h"
	#include "ConstraintParameter.cuh"

	using namespace std;


	/*
	 * 约束的名字信息
	 * */ 
	string ConstraintParameter::constraintName = "benchmark69";

	/*
	 * 约束的变量类型，使用bool变量表示，1表示浮点数，0表示整形
	 * */ 
	bool ConstraintParameter::constraintVarType[NUM_OF_PARAM] = { 1 , 1 , 1 , 1 , 1 , 1 };

	/*
	 * 变量的名字信息
	 * */ 
	string ConstraintParameter::constraintVarName[NUM_OF_PARAM] = { "x" , "y" , "z" , "w" , "t" , "v" };

	/*
	 * 变量的整体依赖关系，使用bool变量表示，1表示相关，0表示不相关
	 * */ 
	bool ConstraintParameter::constraintDependencyRela[NUM_OF_PARAM] = { true , true , true , true , true , true };

	/*
	 * 所有的约束的比较运算符的类型信息
	 * 1 表示> , >= , < , <=四种情况
	 * 0 表示 == 情况
	 * -1 表示 ！= 情况
	 * */ 
	int ConstraintParameter::constraintCompType[Num_Of_Constraints] =  { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 };

	/*
	 * 这个参数是用来记录当存在不可行解的时候，为什么不存在解的原因
	 * */ 
	string ConstraintParameter::noSolutionInfo = "";

	/*
	 * 所有的求解的结果的保留,这个主要存储的是经过化简求解过的变量的对应的值
	 * */ 
	map<string, FloatType> ConstraintParameter::allVarEqualMap;

	/*
	 * 所有的求解的结果的保留,这个主要存储的是每一个变量的定义域，
	 * */ 
	FloatType ConstraintParameter::left[NUM_OF_PARAM] = {-1.0E10 , -1.0E10 , -1.0E10 , -1.0E10 , -1.0E10 , -1.0E10};

	FloatType ConstraintParameter::right[NUM_OF_PARAM] = {1.0E10 , 1.0E10 , 1.0E10 , 1.0E10 , 1.0E10 , 1.0E10};

	/*
	 * 这个函数主要是针对复合约束预处理后的结果的初始化函数，由于是C++98的标准，没有办法直接初始化
	 * 主要有allVarEqualMap
	 * */ 
	void ConstraintParameter::initConstraintPreprocess()
	{
	}

	/*
	 * 这个函数是用来获取约束的信息
	 * */ 
	vector< vector<string> > ConstraintParameter::getConstraintInfo()
	{
		vector< vector<string> > res;

		vector<string> HeQv1;
		HeQv1.push_back("x-y+tanf(v)>(z+t)/(w+t)");
		HeQv1.push_back("sqrtf(x-t)>z/y");
		HeQv1.push_back("x*y>0");
		HeQv1.push_back("t+w+z>0");
		HeQv1.push_back("x*y>t+w+z");
		HeQv1.push_back("powf(y,t)*cosf(v)>z*2+w*3+x*7");
		HeQv1.push_back("z+w>x+y");
		HeQv1.push_back("x/y>w");
		HeQv1.push_back("x>w+y-z");
		HeQv1.push_back("sqrtf(w*y*z)>log10f(t*x)");
		HeQv1.push_back("x*cosf(t+y)>logf(w*z*3)");
		HeQv1.push_back("cosf(t)*sinf(v)>cosf(y)");
		HeQv1.push_back("cosf(x*y)+cosf(z*w)+cosf(t*v)>sinf(x*y)+sinf(z*w)+sinf(t*v)");

		res.push_back(HeQv1);

		return res;
	}

	/*
	 * 这个函数是用来获取约束的运行时刻值，用于CPU验证
	 * */ 
	vector< vector<RuntimeValue*> > ConstraintParameter::getCoveredInfo(FloatType* nums)
	{
		vector< vector<RuntimeValue*> > res;

		vector<RuntimeValue*> HeQv1;

		RuntimeValue* tmp_0_0 = getConstraintValue_0_0(nums[0] , nums[1] , nums[2] , nums[3] , nums[4] , nums[5]);
		HeQv1.push_back(tmp_0_0);
		RuntimeValue* tmp_0_1 = getConstraintValue_0_1(nums[0] , nums[1] , nums[2] , nums[3] , nums[4] , nums[5]);
		HeQv1.push_back(tmp_0_1);
		RuntimeValue* tmp_0_2 = getConstraintValue_0_2(nums[0] , nums[1] , nums[2] , nums[3] , nums[4] , nums[5]);
		HeQv1.push_back(tmp_0_2);
		RuntimeValue* tmp_0_3 = getConstraintValue_0_3(nums[0] , nums[1] , nums[2] , nums[3] , nums[4] , nums[5]);
		HeQv1.push_back(tmp_0_3);
		RuntimeValue* tmp_0_4 = getConstraintValue_0_4(nums[0] , nums[1] , nums[2] , nums[3] , nums[4] , nums[5]);
		HeQv1.push_back(tmp_0_4);
		RuntimeValue* tmp_0_5 = getConstraintValue_0_5(nums[0] , nums[1] , nums[2] , nums[3] , nums[4] , nums[5]);
		HeQv1.push_back(tmp_0_5);
		RuntimeValue* tmp_0_6 = getConstraintValue_0_6(nums[0] , nums[1] , nums[2] , nums[3] , nums[4] , nums[5]);
		HeQv1.push_back(tmp_0_6);
		RuntimeValue* tmp_0_7 = getConstraintValue_0_7(nums[0] , nums[1] , nums[2] , nums[3] , nums[4] , nums[5]);
		HeQv1.push_back(tmp_0_7);
		RuntimeValue* tmp_0_8 = getConstraintValue_0_8(nums[0] , nums[1] , nums[2] , nums[3] , nums[4] , nums[5]);
		HeQv1.push_back(tmp_0_8);
		RuntimeValue* tmp_0_9 = getConstraintValue_0_9(nums[0] , nums[1] , nums[2] , nums[3] , nums[4] , nums[5]);
		HeQv1.push_back(tmp_0_9);
		RuntimeValue* tmp_0_10 = getConstraintValue_0_10(nums[0] , nums[1] , nums[2] , nums[3] , nums[4] , nums[5]);
		HeQv1.push_back(tmp_0_10);
		RuntimeValue* tmp_0_11 = getConstraintValue_0_11(nums[0] , nums[1] , nums[2] , nums[3] , nums[4] , nums[5]);
		HeQv1.push_back(tmp_0_11);
		RuntimeValue* tmp_0_12 = getConstraintValue_0_12(nums[0] , nums[1] , nums[2] , nums[3] , nums[4] , nums[5]);
		HeQv1.push_back(tmp_0_12);

		res.push_back(HeQv1);

		return res;
	}

	/*
	 * 下面是最后在CPU对求出的可行解向量做验证的函数，
	 * 主要就是计算每一个简单子约束的运行时刻值，以及每一个简单自约束的满足情况
	 * */ 
	RuntimeValue* ConstraintParameter::getConstraintValue_0_0( FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v )
	{
		FloatType value = ( x-y+tanf(v) ) - ( (z+t)/(w+t) );
		bool isCovered = (bool)(value > 0.f);
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_1( FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v )
	{
		FloatType value = ( sqrtf(x-t) ) - ( z/y );
		bool isCovered = (bool)(value > 0.f);
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_2( FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v )
	{
		FloatType value = ( x*y ) - ( 0 );
		bool isCovered = (bool)(value > 0.f);
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_3( FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v )
	{
		FloatType value = ( t+w+z ) - ( 0 );
		bool isCovered = (bool)(value > 0.f);
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_4( FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v )
	{
		FloatType value = ( x*y ) - ( t+w+z );
		bool isCovered = (bool)(value > 0.f);
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_5( FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v )
	{
		FloatType value = ( powf(y,t)*cosf(v) ) - ( z*2+w*3+x*7 );
		bool isCovered = (bool)(value > 0.f);
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_6( FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v )
	{
		FloatType value = ( z+w ) - ( x+y );
		bool isCovered = (bool)(value > 0.f);
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_7( FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v )
	{
		FloatType value = ( x/y ) - ( w );
		bool isCovered = (bool)(value > 0.f);
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_8( FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v )
	{
		FloatType value = ( x ) - ( w+y-z );
		bool isCovered = (bool)(value > 0.f);
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_9( FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v )
	{
		FloatType value = ( sqrtf(w*y*z) ) - ( log10f(t*x) );
		bool isCovered = (bool)(value > 0.f);
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_10( FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v )
	{
		FloatType value = ( x*cosf(t+y) ) - ( logf(w*z*3) );
		bool isCovered = (bool)(value > 0.f);
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_11( FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v )
	{
		FloatType value = ( cosf(t)*sinf(v) ) - ( cosf(y) );
		bool isCovered = (bool)(value > 0.f);
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_12( FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v )
	{
		FloatType value = ( cosf(x*y)+cosf(z*w)+cosf(t*v) ) - ( sinf(x*y)+sinf(z*w)+sinf(t*v) );
		bool isCovered = (bool)(value > 0.f);
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

