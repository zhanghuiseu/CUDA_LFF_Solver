1 LFF Solver整体算法自适应策略
	已经解决：1.1 计算尺度与计算规模的自适应调节：计算尺度缩放模型
		1.1.1 当拟合预测点的数量小于N的时候：运行时刻值计算 --> 分类 --> 拟合 --> 预测。
		1.1.2 当拟合预测点的数量大于N的时候：运行时刻值计算 --> 分类 --> 拟合 --> 求交区间 --> 预测。
	已经解决：1.2 搜索任务计算量和计算规模的自适应调节：参数倒三角模型
		1.2.1 在搜索深度小于H的时候，每一个搜索任务的参数maxPredictNum做按照线性（或者随机）做衰减，主要分为两种情况
		      1.2.1.1 参数很大(1000以上)：衰减率可以大一点，比如0.25
                      1.2.1.2 参数始终(500左右)：衰减率建议小一点，比如0.1
		1.2.2 在搜索深度大于H或者衰减到特定值(衰减下届)的时候，每一个搜索任务的参数maxPredictNum保存恒定
	1.3 预测向量规模和计算能力的自适应调节
		已经解决：1.3.1 除了区间细化预测的值之外，在解区间添加一个随机点，
		1.3.2 除了区间扩展预测的值之外，有计划的向区间的左右边界区间各自随机取点n个；

已经解决：2:关于分支优化策略：目前我们是采用编码方式，我会做一下直接使用分支和使用编码的对比实验，
	我准备专门写一个程序做验证一下效果，结果如下：
	2.1 分支提升到CPU：涉及到分类的计算
	2.2 分支降低到GPU：取消分类，直接计算
	2.3 速度对比规律：这个要从单个任务的计算量n和硬件核心数量Cores一起考虑：
		2.3.1 当 n <= Cores *(0-150%) , 多任务同时计算明显要快，快很多，我测试的数据是平均快80%左右
		2.3.2 当 n >> Cores 的时候，多任务同时计算就要慢一点，大约平均慢3%左右
	2.4 原因分析
		2.4.1 任务的计算数量少的时候，多任务速度快是因为充分使用硬件
		2.4.2 当计算数量远大于硬件Cores的时候，多任务平均要慢3%，因为一个任务就足够占用所有的硬件，所以这个3%要满在任务调度
		2.4.3 从时序图上来分析，也是这样
	2.5 策略选取：分支提升到CPU，多任务同时计算
		2.5.1 我们算法有两个特点：任务数量多，计算增长率慢
		2.5.2 在充分使用硬件的时候计算上是可以加速的，
		2.5.3 根据计算任务增长慢的特点，可以通过拓展策略来实现充分使用硬件来实现计算加速
	

已经解决：3：同时启动多个任务函数去计算，提高GPU的利用率
	3.1 针对带求解约束，多任务同时计算运行时刻值
	3.2 分类计算：分为6类同时计算
	3.3 线性拟合：根据6类同时计算
	3.4 预测值：根据6类同时计算
	3.5 预测解向量的合并：预测矩阵按照行同时合并


已经解决：4：等式约束的精度e的判定，
	4.1 精度的处理： f(x) == g(y)  <===>  abs(f(x)-g(y)) <= e

已经解决：5:基于复合约束的静态分析的策略：约束化简，析取范式的合取子式的排序策略，初始区间判定策略
	5.1排序策略：
	约束数量少的合取子式优先选取求解；若约束数量相等，那么包含等式约束少的优先选取求解；假如等式约束数量相等，那么直接比较约束字符串的长度

        主要处理的基本初等函数分为下面两类：周期函数(也即不存在单调性)和非周期函数(也即存在单调性)，假设f是基本初等函数
        1）三角函数 sin,asin,cos,acos,tan,atan,atan2 由于是周期函数，所以单调性不可以利用，但是在等式的时候可以直接处理
        2）其余的Math中函数ceil,floor,round 对于等式可以处理

        1）指数函数 exp,exp2,exp10 可以利用单调性处理，注意定义域
        2）对数函数 log,log2,log10 可以利用单调性处理，注意定义域
        3）幂函数 pow 可以在某些情况下使用单调性，注意定义域
        4）开方函数 sqrt 可以利用单调性处理，注意定义域


	5.2初始区间的计算策略：根据基本初等函数的性质（单调性，零点等等）来实现约束依赖变量的初始区间的给定
		5.2.1 f(x) > g(y) 根据函数f和g来计算x和y的定义域，其实这个主要是sqrt和log系列函数
        	5.2.2 默认的直接返回全区间
        	5.2.3 使用定义域做初步的不可行判定
        	主要支持的规则：基本初等函数的定义域的计算，
        

	5.3最小不可达集合的计算，基于规则去寻找最小不可达集合，主要是寻找明显的自相矛盾情况
		5.3.1 f(x)>a && f(x)<a   ax+b=c && ax+b=d
		5.3.1 a^2+...+z^2<0   
		主要支持的规则：使用计算好的定义域来做初步的不可行判断；
			 然后使用针对等式约束和不等式约束做几个基本的处理，比如ax+c这种形式的线性表达式的计算，
                         根据计算得到的信息去寻找矛盾的地方，也即最小不可达集合

	5.4约束化简求解策略：根据基本初等函数的性质（单调性，零点等等）来实现对部分简单约束的化简和求解
		5.4.1 化简：只能使用单调性来处理
            	eg f(x)>=f(y) --------->  根据单调性来判断
                   f(x)==f(y) --------->  x=y && x满足f定义域 && y满足f定义域

		5.4.2 求解 ：利用单调性去化简，在某些规则下是可以直接求出来collectZeros部分变量的值
		eg ax-b=0       ------->  x = b/a;
                   a^2+...+z^2=0------->  a=0,...z=0,这里的a....z可以是复合约束

                   主要支持的规则就是左右两边结构相同的情况下，可以根据函数的单调性直接去做花间，但是对于sin等等三角函数，由于他们是周期性的，所以不可以化简
                   但是对于等式无论是什么函数都可以直接化简

	5.5经过上面的针对符合约束的化简求解的过程，加入没有发现最小不可解集合，那么就可以对原有约束做一个变量的替换
		5.5.1 变量替换之后可能出现约束的某一个部分变为产量，那么可以提前计算好，
                      针对替换后的约束，做一个基本的检查，假如发现常量表达式，直接计算好作为替换，以减少计算量

collectZeros
        5.6 为什么要做复杂约束的化简和区间分析呢？
            5.6.1 复杂约束的区间分析和化简对约束求解的影响不太大，至少不是决定性因素，也即约束求解主要还是依赖线性拟合制导
            5.6.2 之前根据SPF抽出的很多的路径分析来看，大量约束存在线简单性形式的不可解集合，这就是我们为什么要做最小不可解集合的原因，区间分析只是分析完最小不可解集合的副产品
            5.6.3 线性制导求解对于特殊形式的约束求解很困难，但是这些约束是有规律可循的，所以我们可以引入约束化简来提高对于复杂等式约束的求解能力
	    5.6.4 所有的这些做的都是基本的线性形式约束和特殊形式的分析，主要是为了提高对复杂等式约束的求解能力


已经解决 6 支持线性拟合函数的图形化展示,这个用于辅助区间的细化和扩展策略的制定
            







