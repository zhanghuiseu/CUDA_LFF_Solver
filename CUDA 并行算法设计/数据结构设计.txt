激进时候的参数设计,激进策略的上限AggressiveSize,这个必须是32的倍数
激进时候的随机值的取值范围，RandomMin，RandomMax
随机取值策略：1）浮点数：在某一个子区间内随机取值，
              2）整  形：连续取值
	这个还有两个考虑：我们这里暂时考虑的步长是1，是不是可以更加激进点，可以考虑2或者更大
  	比如Size是128，整数可以从-63——64连续取值
	               浮点数可以直接从每一个长度为10的区间随机取值（-630-640）
	比如Size是256，整数可以从-127——128连续取值
	               浮点数可以直接从每一个长度为10的区间随机取值（-1270——1280）
    比如Size是512，整数可以从-255——256连续取值
	               浮点数可以直接从每一个长度为10的区间随机取值（-2550——2560）
	比如Size是1024，整数可以从-511——512连续取值
	                浮点数可以直接从每一个长度为10的区间随机取值（-5110——5120）
			  



关于拟合情况的编码分类如下：
先从简单自约束比较运算符来分析，主要分为三类，然后针对每一种情况分析线性拟合情况
1） > , >= , < , <=  
    这个主要分为三种情况
    1.1）斜率为0：全区间
                ：无解
    1.2）斜率补位0：全区间
                   半区间：零点在左边
                         ：零点在右边
                   无解：零点在左边
                       ：零点在右边

2）== ZY的是返回当前Double表示的区间

3）!= 直接返回当前区间，

我目前的想法是遇到==、!=和斜率为0的情况下，返回全区间

case：0
等号和不等号 全区间
判断是否是> 和 >=比较运算符号的处理
斜率为0： abs(y1-y2)<=doubleMin && y1 >=0 && y2>=0 全区间
斜率存在： abs(y1-y2)>doubleMin && y1>=0 && y2>=0 全区间
	 
case1: abs(y1-y2)<=doubleMin && y1 <0 && y2<0        无解
case2: abs(y1-y2)>doubleMin && z>x1 && z<x2 && y1>0 (x1,z)
case3: abs(y1-y2)>doubleMin && z>x1 && z<x2 && y2>0 (z,x2)
case4: abs(y1-y2)>doubleMin && z<x1 && y1 <0 && y2<0 无解(xbefore,d)
case5: abs(y1-y2)>doubleMin && z>x2 && y1 <0 && y2<0 无解(d,xafter)
	 
数据结构：
   double x1，x2；
   double zero；
   bool case0，case1，case2，case3，case4，case5，
   bool hasIntervel；


关于去除不可做拟合的区间:
可以在计算运行时刻值设置一个isValied的flag，和一个父节点的index，寻找前一个不是vailed的index
计算完之后

收集零点的操作：针对每一行，
先计算所有的零点，
if 是case4 && zero > (x-2).left 
记录节点

if 是case4 && zero < (x+2).left 
记录节点

然后统计每一行的数量，

规约求和

然后合并
规约合并
按照每一行去做合并












