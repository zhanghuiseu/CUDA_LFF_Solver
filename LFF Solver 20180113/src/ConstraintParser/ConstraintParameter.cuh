/*
 * ConstraintParameter.cuh
 * 
 * ***************   Notice   ***************
 * Auto Generated By ATPC on:2018-01-13 18:06:07
 * Author: ZhangHui
 * 
 */ 

#ifndef CONSTRAINTPARAMETER_CUH_
#define CONSTRAINTPARAMETER_CUH_

#include <string>
#include <vector>
#include <map>
#include <iostream>

#include <cmath>

#include "./../model/RuntimeValue.h"
#include "./../solver/type.h"

#include "./../solver/SolverParameter.h"

using namespace std;

/*
 * 这个类是经过约束依赖分析分析
 * */
class ConstraintParameter
{
public:
	/*
	 * 目标约束的参数数量
	 * */ 
	static const int NUM_OF_PARAM = 6;

	/*
	 * 约束的名字信息
	 * */ 
	static string constraintName;

	/*
	 * 约束的变量类型，使用bool变量表示，1表示浮点数，0表示整形
	 * */ 
	static bool constraintVarType[NUM_OF_PARAM];

	/*
	 * 变量的名字信息
	 * */ 
	static string constraintVarName[NUM_OF_PARAM];

	/*
	 * 变量的整体依赖关系，使用bool变量表示，1表示相关，0表示不相关
	 * */ 
	static bool constraintDependencyRela[NUM_OF_PARAM];

	/*
	 * 所有的约束的数量
	 * */ 
	static const int Num_Of_Constraints = 13;

	/*
	 * 所有的约束的比较运算符的类型信息
	 * */ 
	static int constraintCompType[Num_Of_Constraints];

	/*
	 * 针对复杂约束昨晚化简和定义域求解之后，然后求解最小不可达集合，确定是否是无解的标志变量
	 *  eg x>0 && x<0  <===> 无解
	 * 1）有解 ---------- true  没找到最小不可达集合，所以无法确定无解，也即有解
	 * 2）无解 ---------- false 存在最小不可达集合，也即可以直接判定无解
	 * */ 
	static const bool hasSolution = true;

	/*
	 * 这个参数是用来记录当存在不可行解的时候，为什么不存在解的原因
	 * */ 
	static string noSolutionInfo;

	/*
	 * 这连个变量是定义求解的定义域的最大最小值，为什么用这两个值
	 * 的原因是这样的，首先这连个值的大小基本够用，其次这样容易去
	 * 做判断到底是区间走势
	 * */ 
	static const FloatType minNum = -1.0E10;
	static const FloatType maxNum = 1.0E10;

	/*
	 * 所有的求解的结果的保留,这个主要存储的是经过化简求解过的变量的对应的值
	 * */ 
	static map<string, FloatType> allVarEqualMap;

	/*
	 * 所有的求解的结果的保留,这个主要存储的是每一个变量的定义域
	 * */ 
	static FloatType left[NUM_OF_PARAM];
	static FloatType right[NUM_OF_PARAM];

	/*
	 * 这个函数主要是针对复合约束预处理后的结果的初始化函数，由于是C++98的标准，没有办法直接初始化
	 * 主要有allVarEqualMap
	 * */ 
	static void initConstraintPreprocess();

	/*
	 * 这个函数是用来获取约束的信息
	 * */ 
	static vector< vector<string> > getConstraintInfo();
	static vector< vector<RuntimeValue*> > getCoveredInfo(FloatType* nums);

	/*
	 * 下面是最后在CPU对求出的可行解向量做验证的函数，
	 * 主要就是计算每一个简单子约束的运行时刻值，以及每一个简单自约束的满足情况
	 * */ 
	static RuntimeValue* getConstraintValue_0_0(FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v);
	static RuntimeValue* getConstraintValue_0_1(FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v);
	static RuntimeValue* getConstraintValue_0_2(FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v);
	static RuntimeValue* getConstraintValue_0_3(FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v);
	static RuntimeValue* getConstraintValue_0_4(FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v);
	static RuntimeValue* getConstraintValue_0_5(FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v);
	static RuntimeValue* getConstraintValue_0_6(FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v);
	static RuntimeValue* getConstraintValue_0_7(FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v);
	static RuntimeValue* getConstraintValue_0_8(FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v);
	static RuntimeValue* getConstraintValue_0_9(FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v);
	static RuntimeValue* getConstraintValue_0_10(FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v);
	static RuntimeValue* getConstraintValue_0_11(FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v);
	static RuntimeValue* getConstraintValue_0_12(FloatType x , FloatType y , FloatType z , FloatType w , FloatType t , FloatType v);
};

#endif /* CONSTRAINTPARAMETER_CUH_ */
