	/*
	 * ParallelATG.cuh
	 *
	 *  Created on: Nov 4, 2017
	 *      Author: zy
	 */

	#ifndef PARALLELATG_CUH_
	#define PARALLELATG_CUH_

	#include <iostream>

	#include "./../ConstraintParser/ConstraintParameter.cuh"
	#include "./../model/CoodinateDouble.cuh"
	#include "./../model/IntervalDouble.cuh"
	#include "./../model/PriorityDouble.cuh"
	#include "./../model/FullCoveredInfo.cuh"
	#include "./../model/Classification.cuh"
	#include "./../model/PredictValue.cuh"
    #include "./../solver/ATG.h"
	#include "./../solver/PCATG.h"
	#include "HardwareStrategy.cuh"
	#include "CLF.cuh"

	#include "cuda_runtime.h"
	#include "device_launch_parameters.h"

	using namespace std;

	/*
	 * 下面是部分声明的核函数
	 * */

	/*
	 *  这个核函数是在上一轮的预测解中寻找可行解
	 *  利用了折半查找的思想，不过这里使用并行化直接查找
	 * */
	__global__ void findFullCoverIndex(FullCoveredInfo* dev_coveredInfo,const int step,const int SIZE);

	/*
	 *  这个核函数是计算所有的有效的接向量的数量
	 *  利用了折半查找的思想，不过这里使用并行化直接查找
	 * */
	__global__ void sumOfVaildSolution(FullCoveredInfo* dev_coveredInfo,const int step,const int SIZE);

	/*
	 * 测试核函数，这个是测试极端函数值的一个函数
	 * */
	__global__ void testExtremeValue(double* dev_a,double* dev_b,double* dev_res,const int SIZE);

	/*
	 *  根据节点的信息计算并更新分类信息
	 *  注意，上述的case0-5都是相互独立的，也即是说。两个点的只能属于case0-5的其中一个
	 * */
	__global__ void classification(Classification* dev_classification,CoodinateDouble* dev_calaArray,
			const int calaArraySize,const int cmpType);

	/*
	 * 解区间的初始化
	 * */
	__global__ void initIntervel(IntervalDouble* dev_interval,CoodinateDouble* dev_calaArray,const int calaArraySize);

	/*
	 * 根据分类情况分别计算可行解区间
	 * 一共6中情况，如下，分别表示case0-5
	 *  100000 32 case5
	 *  010000 16 case4
	 *  001000 8  case3
	 *  000100 4  case2
	 *  000010 2  case1
	 *  000001 1  case0
	 *  000000 这种情况不可能出现
	 * */
	__global__ void calaIntervelForCase0(IntervalDouble* dev_interval,Classification* dev_classification,CoodinateDouble* dev_calaArray,
			const int calaArraySize);
	__global__ void calaIntervelForCase1(IntervalDouble* dev_interval,Classification* dev_classification,CoodinateDouble* dev_calaArray,
			const int calaArraySize);
	__global__ void calaIntervelForCase2(IntervalDouble* dev_interval,Classification* dev_classification,CoodinateDouble* dev_calaArray,
			const int calaArraySize);
	__global__ void calaIntervelForCase3(IntervalDouble* dev_interval,Classification* dev_classification,CoodinateDouble* dev_calaArray,
			const int calaArraySize);
	__global__ void calaIntervelForCase4(IntervalDouble* dev_interval,Classification* dev_classification,CoodinateDouble* dev_calaArray,
			const int calaArraySize);
	__global__ void calaIntervelForCase5(IntervalDouble* dev_interval,Classification* dev_classification,CoodinateDouble* dev_calaArray,
			const int calaArraySize);
	__global__ void calaIntervelForCaseNo(IntervalDouble* dev_interval,Classification* dev_classification,CoodinateDouble* dev_calaArray,
			const int calaArraySize);

	/*
	 * 计算黄金分割点
	 * */
	__global__ void calaGoldenPoint(PredictValue* dev_PredictValue,IntervalDouble* dev_finalIntervel,const int calaArraySize);

	__device__ double getGoldenPoint(double left,double right);


	/*
	 *
	 * */
	__global__ void calaPredictNum(int* dev_count,PredictValue* dev_PredictValue,const int calaArraySize);



class ParallelATG
{
public:
	/*
	 * 这个是设计好的随机取点的范围长度,就是在某一个点周围的[i-len/2,i+len/2]这个区间作为起始区间去做搜索
	 * */
	static const int RandomLengthInt = 1024;
	static const int StepInt = 1;
	static const int RandomLengthFloat = 1024;
	static const int StepDouble = 1;

public:
	/*
	 * 这个是CUDA并行化的入口
	 * */
	static int generateTestDataForSolver(const int MaxTryParamSize);

	/*
	 * 完成第一步的初始化，初始化的思想是在给出的当前的搜索的起点周围扩展，分为下面两种情况
	 * 1）对于整形int： 直接[i-RandomLengthInt/2,i+RandomLengthInt/2]做扩展，step一般为1
	 * 2）对于浮点型float：直接[i-RandomLengthFloat/2,i+RandomLengthFloat/2]做扩展，step一般为1
	 * */
	static void initRandomMatrix(CoodinateDouble (*initMat)[RandomLengthInt],int row,int col);


	/*
	 * 判断是否有满足复合约束的可行解
	 * */
	static void isFullCovered(FullCoveredInfo* dev_coveredInfo,CoodinateDouble* dev_all,const int row,const int col);

	/*
	 * 上一轮的预测点执行结束之后判断是否存在已经覆盖复合约束的解向量
	 * 假如存在，直接返回对应的index即可
	 * 否则参与接下来的预测
	 * */
	static void getFullCoveredIndex(FullCoveredInfo* coveredInfo,FullCoveredInfo* dev_coveredInfo,CoodinateDouble* dev_all,
			const int row,const int col);

	/*
	 * 把calaArray和predictArray合并到一起，这里做的就是一个简单的归并，
	 * 关于这个函数并行化的做法的效率问题：
	 * 我查阅过并行版本的归并排序mergeSort，它的合并部分就是这么做的，所以这里也采用这样的做法
	 * */
	static CoodinateDouble* mergePredictArrayToCalaArray(FullCoveredInfo* dev_coveredInfo,CoodinateDouble* dev_calaArray,const int calaArraySize,
				CoodinateDouble* dev_predictArray,const int predictArraySize,const int vaildPredictArraySize, const int row);

	/*
	 * 启动分类操作
	 * */
	static void classificationForAllCase(Classification* dev_classification,CoodinateDouble* dev_calaArray,
				const int calaArraySize,const int row);

	/*
	 * 计算拟合函数，其实就是计算可行解区间
	 * */
	static void calsCLFF(IntervalDouble* dev_intervel,Classification* dev_classification,CoodinateDouble* dev_calaArray,
			const int calaArraySize,const int row);

	/*
	 * 区间交运算
	 * */
	static void intersectionIntervel(IntervalDouble* dev_finalIntervel,IntervalDouble* dev_interval,const int calaArraySize);


	/*
	 * 根据归并区间生成测试用例
	 * */
	static void calaPredictValueFromFinalInterval(PredictValue* dev_PredictValue,IntervalDouble* dev_finalIntervel,const int calaArraySize);

	/*
	 * 统计预测值的数量
	 * */
	static int calaPredictValueSize(PredictValue* dev_PredictValue,const int calaArraySize);

	/*
	 * 打印函数
	 * */
	static void printRandomMat(CoodinateDouble (*initMat)[RandomLengthInt],int row,int col);

	/*
	 * merge合并过程的测试函数
	 * */
	static void testMergeFunction();

	/*
	 * 验证运行时刻值得测试函数
	 * */
	static void testExtremeRumtimeValue();

};

#endif /* PARALLELATG_CUH_ */
