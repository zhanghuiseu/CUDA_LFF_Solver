#include <thrust/device_vector.h>
#include <thrust/copy.h>
#include <vector>
#include <list>
#include <stdio.h>

#include "hello.cuh"
#include "Point.h"

#include <thrust/host_vector.h>
#include <thrust/copy.h>
#include <thrust/fill.h>
#include <thrust/sequence.h>
using namespace std;


__global__ void kernel_PointMult(Point* p, Point* res,const int SIZE)
{
	int i = threadIdx.x + blockIdx.x*blockDim.x;
	while (i < SIZE)
	{
		if(i>=1)
		{
			int x1=p[i-1].x;
			int y1=p[i-1].y;

			int x2=p[i].x;
			int y2=p[i].y;

			res[i-1].x = (y2-y1)/(x2-x1);
			res[i-1].y = x * y;
		}
		i += gridDim.x * blockDim.x;
	}
}



int mainFotPoint()
{
	cout<<endl<<"FFFFFFFFFFF  PPPPOINT    "<<endl;
	const int SIZE=100;

	vector<Point> stlVec;
	for(int i=0;i<SIZE;i++)
	{
		Point one=Point(i,i+1);
		stlVec.push_back(one);
	}

	thrust::device_vector<Point> array_device(stlVec.begin(),stlVec.end());
	thrust::device_vector<Point> res_device(array_device.begin(),array_device.end()-1);


    Point* raw_pointer = thrust::raw_pointer_cast(&array_device[0]);
    Point* res_pointer = thrust::raw_pointer_cast(&res_device[0]);

    kernel_PointMult<<<32,128>>>(raw_pointer,res_pointer,array_device.size());


	thrust::host_vector<Point> array_host = array_device;
    for(int i=0;i<array_host.size();i++)
    	cout<<" ( "<<array_host[i].x<<" , "<<array_host[i].y<<") , ";
    cout<<endl;

    thrust::host_vector<Point> res_host = res_device;
    for(int i=0;i<res_host.size();i++)
    	cout<<" ( "<<res_host[i].x<<" , "<<res_host[i].y<<") , ";
     cout<<endl;


	return 1;
}
