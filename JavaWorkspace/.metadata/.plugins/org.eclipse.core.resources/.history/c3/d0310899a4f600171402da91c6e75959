package cn.nju.seg.atpc.generate;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class ATPC
{
	/**
	 * 确定自动生成的CUDA代码的数据类型，分为两部分
	 * 1）双精度double--------true
	 * 2）单精度float---------false
	 *  这个变量为true的时候表示自动生成双精度的并行代码，否则自动生成单精度的并行代码
	 */
	public static boolean forDouble = false;
	
	/**
	 * 确定是否使用流并行
	 * 1）使用------------true
	 * 2）不使用----------false
	 */
	public static boolean useStream = true;
	
	
	/**
	 * 确定不等式简单约束（不包含等式约束）是否做一个简单的化简
	 * eg log(x) > log(y) <===> x>y && x>0 && y>0
	 * 1）使用------------true ： 因为化简会产生更多的约束，但是每一个约束都变得简单了
	 * 2）不使用----------false： 直接计算复杂约束的运行时刻值即可
	 */
	public static boolean shouldSimplification = true;
	
	
	/**
	 * 针对复杂约束昨晚化简和定义域求解之后，然后求解最小不可达集合，确定是否是无解的标志变量
	 * eg x>0 && x<0  <===> 无解
	 * 1）有解 ---------- true  没找到最小不可达集合，所以无法确定无解，也即有解
	 * 2）无解 ---------- false 存在最小不可达集合，也即可以直接判定无解
	 */
	public static boolean hasSolution = true;
	
	/**
	 * 这个参数是用来记录当存在不可行解的时候，为什么不存在解的原因
	 */
	public static String noSolutionInfo = "";
	
	
	/**
	 * 这连个变量是定义求解的定义域的最大最小值，为什么用这两个值
	 * 的原因是这样的，首先这连个值的大小基本够用，其次这样容易去
	 * 做判断到底是区间走势
	 */
	public static double minNum = -1e10;
	public static double maxNum =  1e10;
	
	/*
	 * 所有的求解的结果的保留
	 * 这个主要存储的是经过化简求解过的变量的对应的值
	 * */
	public static Map<String, String> allVarEqualMap = new HashMap<String, String>();
	
	/*
	 * 所有的求解的结果的保留
	 * 这个主要存储的是每一个变量的定义域，
	 * */
	public static Map<String, String> allVarDomain = new HashMap<String, String>();
	
}
