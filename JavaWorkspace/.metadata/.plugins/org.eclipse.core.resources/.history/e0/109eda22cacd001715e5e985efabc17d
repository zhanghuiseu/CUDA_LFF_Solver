

	/*
	 * 这个文件是函数获取运行时刻的各种函数的声明
	 * */

	/*
	 * 注意这里计算有两部的计算优化：
	 * 1）在计算运行时刻值的时候，顺便把子约束满足情况计算了
	 * 2）计算子约束的满足情况的时候没有使用if等判断分支结构，
	 *    同时使用到已经计算好的运行时刻值去减少复杂的浮点数计算过程
	 *  这里采用的编码函数命名编码规则是这样的
	 *  getRuntimeValue_i_j表示计算第i个析取范式的第j个约束的运行时刻值
	 * */
	__device__ void getRuntimeValue_0_0(double x,double y,double z,CoodinateDouble* res);
	__device__ void getRuntimeValue_0_1(double x,double y,double z,CoodinateDouble* res);
	__device__ void getRuntimeValue_0_2(double x,double y,double z,CoodinateDouble* res);

	__global__ void calaConstraint_0_0_0(CoodinateDouble* dev_predictArray,double* dev_parameter,const int base,const int calaMatCol);
	__global__ void calaConstraint_0_0_1(CoodinateDouble* dev_predictArray,double* dev_parameter,const int base,const int calaMatCol);
	__global__ void calaConstraint_0_0_2(CoodinateDouble* dev_predictArray,double* dev_parameter,const int base,const int calaMatCol);

	__global__ void calaConstraint_0_1_0(CoodinateDouble* dev_predictArray,double* dev_parameter,const int base,const int calaMatCol);
	__global__ void calaConstraint_0_1_1(CoodinateDouble* dev_predictArray,double* dev_parameter,const int base,const int calaMatCol);
	__global__ void calaConstraint_0_1_2(CoodinateDouble* dev_predictArray,double* dev_parameter,const int base,const int calaMatCol);

	__global__ void calaConstraint_0_2_0(CoodinateDouble* dev_predictArray,double* dev_parameter,const int base,const int calaMatCol);
	__global__ void calaConstraint_0_2_1(CoodinateDouble* dev_predictArray,double* dev_parameter,const int base,const int calaMatCol);
	__global__ void calaConstraint_0_2_2(CoodinateDouble* dev_predictArray,double* dev_parameter,const int base,const int calaMatCol);


	/*
	 * 复合约束的并行计算模块,注意，这个函数还可以使用CUDA提供的流加速计算
	 * */
	void calaRuntimeValue(int paraIndex,CoodinateDouble* dev_predictArray,double* dev_parameter,const int row,const int col);

	/*
	 * 这个是CPU计算模块，是用来验证上面的calaRuntimeValue()函数的验证函数
	 * */
	void checkExcuteConstraint(int paraIndex,CoodinateDouble* all,double* parameter,const int row,const int col);

	/*
	 * 这个核函数是为了寻找可行解
	 * */
	__global__ void calaFeasibleSolution(FullCoveredInfo* dev_coveredInfo,CoodinateDouble* dev_predictArray,const int calaMatCol);

	/*
	 * 判断是否有满足复合约束的可行解,CPU验证模块
	 * */
	bool checkisFullCovered(FullCoveredInfo* dev_coveredInfo,CoodinateDouble* initArray, bool &findSolution,const int row,const int col);


	/*
	 * 就是区间交运算的计算
	 * */
	__global__ void calaFinalIntervel(IntervalDouble* dev_finalIntervel,IntervalDouble* dev_interval,const int calaArraySize);


	/*
	 * 根据预测的序列生成predct矩阵
	 * */
	__global__ void generatePredictMat(CoodinateDouble* dev_predictArray,PredictValue* dev_finalAllPredictValue,const int col);


	/*
	 * 并行计算所有的预测解向量的优先级
	 * */
	__global__ void calaPriority(PriorityDouble* dev_priority,CoodinateDouble* dev_calaArray,const int row,const int Size);


	#endif /* EXCUTECONSTRAINT_CUH_ */
