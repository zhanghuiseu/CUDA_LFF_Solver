	/*
	 * ConstraintParameter.cu
	 * 
	 * ***************   Notice   ***************
	 * Auto Generated By ATPC on:2017-12-02 20:46:00
	 * Author: ZhangHui
	 * 
	 */ 

	#include <iostream>

	#include "./../solver/type.h"
	#include "./../solver/ConstantValue.h"
	#include "./../model/RuntimeValue.h"
	#include "ConstraintParameter.cuh"

	using namespace std;


	/*
	 * 约束的名字信息
	 * */ 
	string ConstraintParameter::constraintName = "TestcudaStream";

	/*
	 * 约束的变量类型，使用bool变量表示，1表示浮点数，0表示整形
	 * */ 
	bool ConstraintParameter::constraintVarType[NUM_OF_PARAM] = { 1 , 1 , 1 , 1 };

	/*
	 * 变量的名字信息
	 * */ 
	string ConstraintParameter::constraintVarName[NUM_OF_PARAM] = { "x1" , "x2" , "x3" , "x4" };

	/*
	 * 变量的整体依赖关系，使用bool变量表示，1表示相关，0表示不相关
	 * */ 
	bool ConstraintParameter::constraintDependencyRela[NUM_OF_PARAM] = { true , true , true , true };

	/*
	 * 所有的约束的比较运算符的类型信息
	 * 1 表示> , >= , < , <=四种情况
	 * 0 表示 == 情况
	 * -1 表示 ！= 情况
	 * */ 
	int ConstraintParameter::constraintCompType[Num_Of_Constraints] =  { 0 , 0 , 0 , 0 , 0 };

	/*
	 * 这个函数是用来获取约束的信息
	 * */ 
	vector< vector<string> > ConstraintParameter::getConstraintInfo()
	{
		vector< vector<string> > res;

		vector<string> HeQv1;
		HeQv1.push_back("1.0-x1==0.0");
		HeQv1.push_back("1.0-x3==0.0");
		HeQv1.push_back("x2-x1*x1==0.0");
		HeQv1.push_back("x4-x3*x3==0.0");
		HeQv1.push_back("x1-x4==0");

		res.push_back(HeQv1);

		return res;
	}

	/*
	 * 这个函数是用来获取约束的运行时刻值，用于CPU验证
	 * */ 
	vector< vector<RuntimeValue*> > ConstraintParameter::getCoveredInfo(FloatType* nums)
	{
		vector< vector<RuntimeValue*> > res;

		vector<RuntimeValue*> HeQv1;

		RuntimeValue* tmp_0_0 = getConstraintValue_0_0(nums[0] , nums[1] , nums[2] , nums[3]);
		HeQv1.push_back(tmp_0_0);
		RuntimeValue* tmp_0_1 = getConstraintValue_0_1(nums[0] , nums[1] , nums[2] , nums[3]);
		HeQv1.push_back(tmp_0_1);
		RuntimeValue* tmp_0_2 = getConstraintValue_0_2(nums[0] , nums[1] , nums[2] , nums[3]);
		HeQv1.push_back(tmp_0_2);
		RuntimeValue* tmp_0_3 = getConstraintValue_0_3(nums[0] , nums[1] , nums[2] , nums[3]);
		HeQv1.push_back(tmp_0_3);
		RuntimeValue* tmp_0_4 = getConstraintValue_0_4(nums[0] , nums[1] , nums[2] , nums[3]);
		HeQv1.push_back(tmp_0_4);

		res.push_back(HeQv1);

		return res;
	}

	/*
	 * 下面是最后在CPU对求出的可行解向量做验证的函数，
	 * 主要就是计算每一个简单子约束的运行时刻值，以及每一个简单自约束的满足情况
	 * */ 
	RuntimeValue* ConstraintParameter::getConstraintValue_0_0( FloatType x1 , FloatType x2 , FloatType x3 , FloatType x4 )
	{
		FloatType value = ( 1.0-x1 ) - ( 0.0 );
		bool isCovered = (1.0-x1==0.0) * true;
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_1( FloatType x1 , FloatType x2 , FloatType x3 , FloatType x4 )
	{
		FloatType value = ( 1.0-x3 ) - ( 0.0 );
		bool isCovered = (1.0-x3==0.0) * true;
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_2( FloatType x1 , FloatType x2 , FloatType x3 , FloatType x4 )
	{
		FloatType value = ( x2-x1*x1 ) - ( 0.0 );
		bool isCovered = (x2-x1*x1==0.0) * true;
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_3( FloatType x1 , FloatType x2 , FloatType x3 , FloatType x4 )
	{
		FloatType value = ( x4-x3*x3 ) - ( 0.0 );
		bool isCovered = (x4-x3*x3==0.0) * true;
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

	RuntimeValue* ConstraintParameter::getConstraintValue_0_4( FloatType x1 , FloatType x2 , FloatType x3 , FloatType x4 )
	{
		FloatType value = ( x1-x4 ) - ( 0 );
		bool isCovered = (x1-x4==0) * true;
		RuntimeValue* one = new RuntimeValue(value,isCovered);
		return one;
	}

